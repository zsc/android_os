<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>附录B：源码编译与定制</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Android OS 深度原理解析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第1章：Android系统架构概览</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第2章：Linux内核层定制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第3章：硬件抽象层(HAL)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第4章：Init进程与系统启动</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第5章：Zygote与应用进程管理</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第6章：Android Runtime (ART)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第7章：Binder IPC机制深度剖析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第8章：系统服务架构</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第9章：ContentProvider与数据共享</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第10章：Android图形系统架构</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第11章：音频系统架构</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第12章：相机与多媒体框架</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第13章：Android安全模型</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第14章：密钥管理与硬件安全</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter15.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第15章：漏洞案例分析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter16.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第16章：Neural Networks API (NNAPI)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter17.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第17章：TensorFlow Lite集成</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter18.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第18章：ML Kit与设备端AI</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter19.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第19章：NPU/TPU硬件加速</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter20.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第20章：协处理器系统集成</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter21.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第21章：MIUI系统架构剖析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter22.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第22章：ColorOS/EMUI技术分析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter23.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第23章：厂商内核与驱动定制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter24.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第24章：厂商AI能力对比</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter25.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第25章：OriginOS深度剖析</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter26.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第26章：Android虚拟化技术</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter27.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第27章：实时性与性能优化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter28.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第28章：逆向工程与安全研究</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter29.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第29章：Android未来演进</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter30.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">附录A：调试工具与技巧</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter31.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">附录B：源码编译与定制</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter32.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第32章：参考资源</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">AndroidOS原理教程项目说明</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="README.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Android OS 深度原理解析</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="b">附录B：源码编译与定制</h1>
<p>本章深入探讨Android开源项目(AOSP)的编译流程、设备定制机制以及系统发布的完整工作流。我们将从环境搭建开始，逐步深入到设备树配置、HAL层开发，最终完成系统签名与发布的全流程。通过本章学习，读者将掌握从源码到产品级ROM的完整技术栈。</p>
<h2 id="_1">目录</h2>
<ol>
<li>
<p><a href="#aosp编译环境">AOSP编译环境</a>
   - 编译环境要求与搭建
   - 源码同步与仓库管理
   - 编译系统架构剖析
   - 编译优化与加速技术</p>
</li>
<li>
<p><a href="#设备树配置">设备树配置</a>
   - Device Tree基础概念
   - BoardConfig详解
   - Product配置体系
   - 与Linux DTS的区别</p>
</li>
<li>
<p><a href="#hal开发指南">HAL开发指南</a>
   - HAL架构演进历程
   - HIDL/AIDL接口设计
   - HAL模块实现流程
   - Vendor Interface最佳实践</p>
</li>
<li>
<p><a href="#系统签名与发布">系统签名与发布</a>
   - Android签名机制详解
   - 密钥管理与安全存储
   - OTA包生成流程
   - 发布验证与回滚机制</p>
</li>
</ol>
<h2 id="aosp">AOSP编译环境</h2>
<h3 id="_2">编译环境要求与搭建</h3>
<p>Android源码编译需要强大的硬件支持和特定的软件环境。AOSP官方推荐的最低配置为：</p>
<ul>
<li><strong>硬件要求</strong>：</li>
<li>CPU：64位多核处理器（建议8核以上）</li>
<li>内存：16GB RAM（建议32GB以上）</li>
<li>存储：400GB可用空间（完整编译需要）</li>
<li>
<p>操作系统：Ubuntu 20.04 LTS或macOS（部分功能受限）</p>
</li>
<li>
<p><strong>软件依赖</strong>：</p>
</li>
<li>JDK版本要求随Android版本变化</li>
<li>Python 3.6+</li>
<li>必要的编译工具链（gcc, g++, make等）</li>
</ul>
<p>环境初始化通过<code>envsetup.sh</code>完成，该脚本设置了编译所需的环境变量和函数。关键函数包括<code>lunch</code>（选择编译目标）、<code>m</code>（新式编译命令）、<code>mm</code>（模块编译）等。</p>
<h3 id="_3">源码同步与仓库管理</h3>
<p>Android使用<code>repo</code>工具管理数百个Git仓库。Repo基于manifest文件定义了各仓库的版本和依赖关系：</p>
<ul>
<li><strong>Manifest结构</strong>：</li>
<li>default.xml定义主分支和远程仓库</li>
<li>project元素指定每个仓库的路径和分支</li>
<li>
<p>remove-project和add-project用于定制</p>
</li>
<li>
<p><strong>同步策略</strong>：</p>
</li>
<li><code>repo sync -j8</code>并行同步提高效率</li>
<li><code>--current-branch</code>仅同步当前分支</li>
<li><code>--no-clone-bundle</code>避免使用预打包数据</li>
</ul>
<p>与iOS的封闭源码不同，Android的开放性带来了版本管理的复杂性。鸿蒙OS采用了类似的多仓库结构，但在manifest组织上有所优化。</p>
<h3 id="_4">编译系统架构剖析</h3>
<p>Android编译系统经历了从Make到Soong的演进：</p>
<ul>
<li><strong>Make时代（Android 6.0前）</strong>：</li>
<li>基于GNU Make的递归构建</li>
<li>Android.mk定义模块</li>
<li>
<p>编译速度慢，依赖关系复杂</p>
</li>
<li>
<p><strong>Soong/Blueprint（Android 7.0+）</strong>：</p>
</li>
<li>基于Go语言的新构建系统</li>
<li>Android.bp使用JSON-like语法</li>
<li>
<p>并行化程度高，增量编译优化</p>
</li>
<li>
<p><strong>Bazel试验（Android 13+）</strong>：</p>
</li>
<li>Google内部使用的构建系统</li>
<li>支持远程缓存和分布式编译</li>
<li>与Soong并存，逐步迁移</li>
</ul>
<p>编译流程的核心步骤：</p>
<ol>
<li><strong>Kati阶段</strong>：将Android.mk转换为ninja文件</li>
<li><strong>Soong阶段</strong>：处理Android.bp生成ninja文件  </li>
<li><strong>Ninja执行</strong>：实际的编译链接过程</li>
<li><strong>打包阶段</strong>：生成system.img等镜像文件</li>
</ol>
<h3 id="_5">编译优化与加速技术</h3>
<p>大型Android项目的编译优化至关重要：</p>
<ul>
<li><strong>ccache使用</strong>：</li>
<li>缓存C/C++编译结果</li>
<li>可将重编译时间缩短50%以上</li>
<li>
<p>需要合理设置缓存大小和策略</p>
</li>
<li>
<p><strong>分布式编译</strong>：</p>
</li>
<li>Goma：Google的分布式编译服务</li>
<li>distcc：开源分布式编译方案</li>
<li>
<p>需要解决依赖同步问题</p>
</li>
<li>
<p><strong>增量编译优化</strong>：</p>
</li>
<li>精确的依赖追踪</li>
<li>模块边界优化</li>
<li>
<p>避免不必要的重新链接</p>
</li>
<li>
<p><strong>构建缓存</strong>：</p>
</li>
<li>本地artifact缓存</li>
<li>远程缓存服务器</li>
<li>容器化编译环境</li>
</ul>
<p>与iOS的Xcode编译相比，Android的编译系统更加开放但也更复杂。鸿蒙的编译系统借鉴了Android的经验，但在模块化和缓存机制上有所改进。</p>
<h2 id="_6">设备树配置</h2>
<h3 id="device-tree">Device Tree基础概念</h3>
<p>Android的设备配置体系与Linux内核的Device Tree有本质区别：</p>
<ul>
<li><strong>Android Device Configuration</strong>：</li>
<li>定义产品级别的配置</li>
<li>包含硬件特性、软件功能</li>
<li>
<p>影响编译时的模块选择</p>
</li>
<li>
<p><strong>Linux Device Tree (DTS)</strong>：</p>
</li>
<li>描述硬件拓扑结构</li>
<li>运行时被内核解析</li>
<li>主要用于驱动初始化</li>
</ul>
<p>Android的设备配置主要通过以下文件体现：</p>
<ul>
<li>BoardConfig.mk：板级配置</li>
<li>device.mk：设备特定配置</li>
<li>AndroidProducts.mk：产品定义入口</li>
</ul>
<h3 id="boardconfig">BoardConfig详解</h3>
<p>BoardConfig.mk是硬件相关配置的核心，关键配置项包括：</p>
<ul>
<li><strong>分区配置</strong>：</li>
<li>BOARD_BOOTIMAGE_PARTITION_SIZE</li>
<li>BOARD_SYSTEMIMAGE_PARTITION_SIZE</li>
<li>BOARD_VENDORIMAGE_PARTITION_SIZE</li>
<li>
<p>动态分区配置（Android 10+）</p>
</li>
<li>
<p><strong>内核配置</strong>：</p>
</li>
<li>TARGET_KERNEL_CONFIG：内核defconfig</li>
<li>BOARD_KERNEL_CMDLINE：内核启动参数</li>
<li>
<p>TARGET_PREBUILT_KERNEL：预编译内核路径</p>
</li>
<li>
<p><strong>HAL配置</strong>：</p>
</li>
<li>BOARD_HAL_STATIC_LIBRARIES</li>
<li>DEVICE_MANIFEST_FILE：HAL接口声明</li>
<li>
<p>DEVICE_MATRIX_FILE：兼容性矩阵</p>
</li>
<li>
<p><strong>SELinux配置</strong>：</p>
</li>
<li>BOARD_SEPOLICY_DIRS：策略文件目录</li>
<li>BOARD_PLAT_PRIVATE_SEPOLICY_DIR</li>
<li>厂商特定的策略扩展</li>
</ul>
<h3 id="product">Product配置体系</h3>
<p>Android的产品配置采用继承机制，支持灵活的定制：</p>
<ul>
<li><strong>继承链</strong>：</li>
<li>generic产品：AOSP基础配置</li>
<li>sdk产品：模拟器配置</li>
<li>
<p>厂商产品：继承并扩展</p>
</li>
<li>
<p><strong>关键变量</strong>：</p>
</li>
<li>PRODUCT_NAME：产品名称</li>
<li>PRODUCT_DEVICE：关联的设备</li>
<li>PRODUCT_PACKAGES：包含的应用和服务</li>
<li>
<p>PRODUCT_PROPERTY_OVERRIDES：系统属性</p>
</li>
<li>
<p><strong>Makefile继承机制</strong>：</p>
</li>
<li>$(call inherit-product, ...)</li>
<li>变量追加vs覆盖规则</li>
<li>
<p>条件编译支持</p>
</li>
<li>
<p><strong>多产品管理</strong>：</p>
</li>
<li>同一设备支持多个产品配置</li>
<li>通过lunch菜单选择</li>
<li>自动化构建的产品矩阵</li>
</ul>
<h3 id="linux-dts">与Linux DTS的区别</h3>
<p>虽然名称相似，但Android Device Tree与Linux DTS有本质区别：</p>
<p>|特性|Android Device Config|Linux DTS|</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Android Device Config</th>
<th>Linux DTS</th>
</tr>
</thead>
<tbody>
<tr>
<td>作用时机</td>
<td>编译时</td>
<td>运行时</td>
</tr>
<tr>
<td>描述内容</td>
<td>产品功能配置</td>
<td>硬件拓扑结构</td>
</tr>
<tr>
<td>格式</td>
<td>Makefile</td>
<td>设备树源码</td>
</tr>
<tr>
<td>解析方式</td>
<td>Make/Soong处理</td>
<td>内核dtb解析</td>
</tr>
<tr>
<td>修改影响</td>
<td>需要重新编译</td>
<td>可动态加载</td>
</tr>
</tbody>
</table>
<p>Android在底层仍然使用Linux DTS描述硬件，但上层的产品配置独立演进。这种分离使得：</p>
<ul>
<li>同一硬件可以有多种产品形态</li>
<li>软件功能配置与硬件描述解耦</li>
<li>支持更灵活的产品定制</li>
</ul>
<h2 id="hal">HAL开发指南</h2>
<h3 id="hal_1">HAL架构演进历程</h3>
<p>Hardware Abstraction Layer (HAL)是Android系统的关键组件，其架构经历了重大演进：</p>
<ul>
<li><strong>Legacy HAL（Android 8.0前）</strong>：</li>
<li>基于C结构体的接口定义</li>
<li>通过dlopen动态加载</li>
<li>紧耦合，难以升级</li>
<li>
<p>hw_module_t和hw_device_t基础结构</p>
</li>
<li>
<p><strong>Project Treble HAL（Android 8.0+）</strong>：</p>
</li>
<li>HIDL (HAL Interface Definition Language)</li>
<li>进程隔离，支持直通和绑定模式</li>
<li>Vendor/System分区解耦</li>
<li>
<p>版本化接口管理</p>
</li>
<li>
<p><strong>AIDL HAL（Android 11+）</strong>：</p>
</li>
<li>统一使用AIDL替代HIDL</li>
<li>更好的向后兼容性</li>
<li>简化的接口定义</li>
<li>支持稳定的AIDL接口</li>
</ul>
<h3 id="hidlaidl">HIDL/AIDL接口设计</h3>
<p>接口定义语言是HAL开发的核心：</p>
<ul>
<li><strong>HIDL特性</strong>：</li>
<li>强类型接口定义</li>
<li>自动生成客户端/服务端代码</li>
<li>支持同步和异步调用</li>
<li>
<p>版本管理机制（major.minor）</p>
</li>
<li>
<p><strong>AIDL for HAL特性</strong>：</p>
</li>
<li>与应用层AIDL语法一致</li>
<li>@VintfStability标记稳定接口</li>
<li>支持parcelable数据类型</li>
<li>
<p>更灵活的版本演进</p>
</li>
<li>
<p><strong>接口设计原则</strong>：</p>
</li>
<li>最小化接口原则</li>
<li>错误处理标准化</li>
<li>异步操作的回调设计</li>
<li>
<p>资源生命周期管理</p>
</li>
<li>
<p><strong>性能考虑</strong>：</p>
</li>
<li>直通模式vs绑定模式选择</li>
<li>批量操作接口设计</li>
<li>内存映射的正确使用</li>
<li>避免频繁的跨进程调用</li>
</ul>
<h3 id="hal_2">HAL模块实现流程</h3>
<p>完整的HAL模块开发包含以下步骤：</p>
<ol>
<li>
<p><strong>接口定义</strong>：
   - 创建.hal或.aidl文件
   - 定义数据类型和方法
   - 指定版本号
   - 编写接口文档</p>
</li>
<li>
<p><strong>代码生成</strong>：
   - hidl-gen/aidl工具生成框架代码
   - 生成的文件包括：</p>
<ul>
<li>C++/Java客户端代码</li>
<li>服务端骨架代码</li>
<li>VTS测试框架</li>
</ul>
</li>
<li>
<p><strong>实现开发</strong>：
   - 继承生成的接口类
   - 实现具体的硬件操作
   - 处理并发和同步
   - 资源管理和错误处理</p>
</li>
<li>
<p><strong>服务注册</strong>：
   - 实现服务入口点
   - 注册到hwservicemanager
   - 配置SELinux权限
   - 设置init.rc启动脚本</p>
</li>
<li>
<p><strong>测试验证</strong>：
   - VTS (Vendor Test Suite)测试
   - CTS验证兼容性
   - 性能基准测试
   - 稳定性测试</p>
</li>
</ol>
<h3 id="vendor-interface">Vendor Interface最佳实践</h3>
<p>Vendor Interface设计直接影响系统的可维护性：</p>
<ul>
<li><strong>接口稳定性</strong>：</li>
<li>只暴露必要的硬件功能</li>
<li>避免实现细节泄露</li>
<li>使用feature flag管理可选功能</li>
<li>
<p>保持向后兼容性</p>
</li>
<li>
<p><strong>性能优化</strong>：</p>
</li>
<li>合理使用FMQ (Fast Message Queue)</li>
<li>批量操作减少IPC开销</li>
<li>共享内存用于大数据传输</li>
<li>
<p>异步接口避免阻塞</p>
</li>
<li>
<p><strong>错误处理</strong>：</p>
</li>
<li>统一的错误码定义</li>
<li>详细的错误信息</li>
<li>优雅的降级策略</li>
<li>
<p>避免崩溃传播</p>
</li>
<li>
<p><strong>版本管理</strong>：</p>
</li>
<li>次版本向后兼容</li>
<li>主版本允许breaking change</li>
<li>多版本共存支持</li>
<li>清晰的废弃策略</li>
</ul>
<p>与iOS的IOKit驱动模型相比，Android的HAL提供了更好的用户空间隔离。鸿蒙的驱动框架则采用了更激进的用户态驱动设计。</p>
<h2 id="_7">系统签名与发布</h2>
<h3 id="android">Android签名机制详解</h3>
<p>Android采用多层签名机制保护系统完整性：</p>
<ul>
<li><strong>APK签名</strong>：</li>
<li>V1签名：JAR签名，兼容性好</li>
<li>V2签名：整包签名，安全性高</li>
<li>V3签名：支持密钥轮换</li>
<li>
<p>V4签名：增量更新支持</p>
</li>
<li>
<p><strong>系统镜像签名</strong>：</p>
</li>
<li>boot.img：内核和ramdisk签名</li>
<li>system.img：dm-verity保护</li>
<li>vendor.img：独立签名验证</li>
<li>
<p>vbmeta.img：AVB统一验证</p>
</li>
<li>
<p><strong>签名密钥类型</strong>：</p>
</li>
<li>platform：系统核心应用</li>
<li>shared：共享UID应用</li>
<li>media：媒体相关应用</li>
<li>
<p>testkey：测试密钥（禁止生产使用）</p>
</li>
<li>
<p><strong>证书链验证</strong>：</p>
</li>
<li>OEM根证书</li>
<li>中间证书（可选）</li>
<li>终端实体证书</li>
<li>证书固定和轮换机制</li>
</ul>
<h3 id="_8">密钥管理与安全存储</h3>
<p>生产环境的密钥管理至关重要：</p>
<ul>
<li><strong>密钥生成</strong>：</li>
<li>使用HSM（Hardware Security Module）</li>
<li>足够的密钥长度（RSA 4096/EC P-256）</li>
<li>安全的随机数生成</li>
<li>
<p>密钥用途分离</p>
</li>
<li>
<p><strong>密钥存储</strong>：</p>
</li>
<li>离线密钥保管库</li>
<li>多人控制的密钥访问</li>
<li>定期密钥审计</li>
<li>
<p>紧急密钥撤销机制</p>
</li>
<li>
<p><strong>构建时签名</strong>：</p>
</li>
<li>签名服务器隔离</li>
<li>最小权限原则</li>
<li>构建日志审计</li>
<li>
<p>防重放攻击</p>
</li>
<li>
<p><strong>密钥轮换</strong>：</p>
</li>
<li>计划性密钥更新</li>
<li>平滑过渡期</li>
<li>旧密钥安全销毁</li>
<li>应急响应预案</li>
</ul>
<h3 id="ota">OTA包生成流程</h3>
<p>Over-The-Air更新是Android系统维护的核心：</p>
<ul>
<li><strong>完整包生成</strong>：</li>
<li>target-files.zip准备</li>
<li>ota_from_target_files工具</li>
<li>元数据和载荷生成</li>
<li>
<p>签名和校验</p>
</li>
<li>
<p><strong>差分包生成</strong>：</p>
</li>
<li>源版本和目标版本对比</li>
<li>bsdiff/imgdiff算法</li>
<li>最优差分策略</li>
<li>
<p>压缩和优化</p>
</li>
<li>
<p><strong>A/B更新机制</strong>：</p>
</li>
<li>双分区设计</li>
<li>后台静默更新</li>
<li>无缝切换</li>
<li>
<p>自动回滚保护</p>
</li>
<li>
<p><strong>动态分区支持</strong>：</p>
</li>
<li>super分区管理</li>
<li>分区大小调整</li>
<li>COW快照机制</li>
<li>空间优化策略</li>
</ul>
<h3 id="_9">发布验证与回滚机制</h3>
<p>可靠的发布流程需要完善的验证和回滚：</p>
<ul>
<li><strong>发布前验证</strong>：</li>
<li>自动化测试套件</li>
<li>兼容性测试（CTS/VTS/GTS）</li>
<li>性能回归测试</li>
<li>
<p>安全扫描</p>
</li>
<li>
<p><strong>灰度发布</strong>：</p>
</li>
<li>分阶段推送策略</li>
<li>A/B测试框架</li>
<li>实时监控指标</li>
<li>
<p>快速止损机制</p>
</li>
<li>
<p><strong>回滚设计</strong>：</p>
</li>
<li>自动回滚触发条件</li>
<li>数据迁移兼容性</li>
<li>版本降级限制</li>
<li>
<p>用户数据保护</p>
</li>
<li>
<p><strong>监控和响应</strong>：</p>
</li>
<li>崩溃率监控</li>
<li>性能指标追踪</li>
<li>用户反馈渠道</li>
<li>紧急修复流程</li>
</ul>
<p>与iOS的集中式更新不同，Android的OTA机制需要考虑更多的设备差异性。鸿蒙OS在此基础上增加了跨设备协同更新的能力。</p>
<h2 id="_10">本章小结</h2>
<p>本章深入剖析了Android系统从源码到发布的完整技术栈：</p>
<ol>
<li>
<p><strong>编译系统</strong>的演进体现了大规模软件工程的最佳实践，从Make到Soong再到Bazel的转变反映了对构建效率的不断追求</p>
</li>
<li>
<p><strong>设备配置</strong>体系通过分离编译时配置和运行时硬件描述，实现了灵活的产品定制能力</p>
</li>
<li>
<p><strong>HAL架构</strong>从Legacy到Treble的演进解决了系统更新的碎片化问题，HIDL/AIDL提供了稳定的硬件抽象接口</p>
</li>
<li>
<p><strong>签名和发布</strong>机制通过多层验证和渐进式更新策略，在开放生态中保证了系统安全性和可靠性</p>
</li>
</ol>
<p>关键技术要点：</p>
<ul>
<li>理解repo多仓库管理和Soong构建系统原理</li>
<li>掌握BoardConfig.mk和Product配置的继承机制  </li>
<li>熟悉HIDL/AIDL接口设计和HAL模块开发流程</li>
<li>了解Android签名体系和OTA更新机制</li>
</ul>
<h2 id="_11">练习题</h2>
<h3 id="1">1. 编译系统分析题</h3>
<p>Soong编译系统相比传统Make系统的主要优势是什么？请分析Android.bp相比Android.mk在以下方面的改进：</p>
<ul>
<li>语法表达能力</li>
<li>并行编译支持</li>
<li>依赖关系管理</li>
<li>错误诊断能力</li>
</ul>
<p><strong>Hint</strong>: 考虑Soong使用Go语言实现的优势，以及Blueprint的设计理念</p>
<details>
<summary>参考答案</summary>
<p>Soong编译系统的主要优势：</p>
<ol>
<li>
<p><strong>语法表达能力</strong>：
   - Android.bp使用类JSON语法，更加清晰简洁
   - 强类型检查，编译时发现配置错误
   - 支持更复杂的条件编译和配置继承</p>
</li>
<li>
<p><strong>并行编译支持</strong>：
   - 基于Ninja的并行执行引擎
   - 更精确的依赖关系图
   - 避免了Make的递归调用开销</p>
</li>
<li>
<p><strong>依赖关系管理</strong>：
   - 自动依赖分析，无需手动声明
   - 模块边界清晰，减少重复编译
   - 支持细粒度的增量编译</p>
</li>
<li>
<p><strong>错误诊断能力</strong>：
   - 编译时类型检查
   - 更友好的错误信息
   - 模块依赖循环检测</p>
</li>
</ol>
</details>
<h3 id="2">2. 设备配置实践题</h3>
<p>假设你要为一个新的开发板适配Android，该开发板具有以下特性：</p>
<ul>
<li>4GB RAM，64GB存储</li>
<li>支持A/B分区更新</li>
<li>使用Mali GPU</li>
<li>需要自定义音频HAL</li>
</ul>
<p>请列出需要创建的主要配置文件及其关键内容。</p>
<p><strong>Hint</strong>: 考虑device/vendor目录结构和继承关系</p>
<details>
<summary>参考答案</summary>
<p>需要创建的主要配置文件：</p>
<ol>
<li><strong>device/[vendor]/[board]/BoardConfig.mk</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="n">TARGET_BOARD_PLATFORM</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">platform_name</span><span class="o">]</span>
<span class="n">TARGET_BOOTLOADER_BOARD_NAME</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">board_name</span><span class="o">]</span>

<span class="err">#</span><span class="w"> </span><span class="n">分区大小配置</span>
<span class="n">BOARD_BOOTIMAGE_PARTITION_SIZE</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="mi">67108864</span>
<span class="n">BOARD_SYSTEMIMAGE_PARTITION_SIZE</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="mi">3221225472</span>

<span class="err">#</span><span class="w"> </span><span class="n">A</span><span class="o">/</span><span class="n">B更新支持</span>
<span class="n">AB_OTA_UPDATER</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="k">true</span>
<span class="n">AB_OTA_PARTITIONS</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="n">boot</span><span class="w"> </span><span class="k">system</span><span class="w"> </span><span class="n">vendor</span>

<span class="err">#</span><span class="w"> </span><span class="n">GPU配置</span>
<span class="n">BOARD_GPU_DRIVERS</span><span class="w"> </span><span class="err">:</span><span class="o">=</span><span class="w"> </span><span class="n">mali</span>
</code></pre></div>

<ol start="2">
<li><strong>device/[vendor]/[board]/device.mk</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="cp"># 继承基础配置</span>
<span class="n">$</span><span class="p">(</span><span class="n">call</span><span class="w"> </span><span class="n">inherit</span><span class="o">-</span><span class="n">product</span><span class="p">,</span><span class="w"> </span><span class="n">$</span><span class="p">(</span><span class="n">SRC_TARGET_DIR</span><span class="p">)</span><span class="o">/</span><span class="n">product</span><span class="o">/</span><span class="n">core_64_bit</span><span class="p">.</span><span class="n">mk</span><span class="p">)</span>

<span class="cp"># 音频HAL</span>
<span class="n">PRODUCT_PACKAGES</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span>\
<span class="w">    </span><span class="n">android</span><span class="p">.</span><span class="n">hardware</span><span class="p">.</span><span class="n">audio</span><span class="mf">@6.0</span><span class="o">-</span><span class="n">impl</span><span class="w"> </span>\
<span class="w">    </span><span class="n">android</span><span class="p">.</span><span class="n">hardware</span><span class="p">.</span><span class="n">audio</span><span class="p">.</span><span class="n">service</span>
</code></pre></div>

<ol start="3">
<li>
<p><strong>device/[vendor]/[board]/AndroidProducts.mk</strong>：
   定义产品入口</p>
</li>
<li>
<p><strong>device/[vendor]/[board]/manifest.xml</strong>：
   声明HAL接口版本</p>
</li>
</ol>
</details>
<h3 id="3-hal">3. HAL接口设计题</h3>
<p>设计一个简单的LED控制HAL接口，支持：</p>
<ul>
<li>设置LED颜色（RGB）</li>
<li>设置闪烁模式</li>
<li>查询LED状态</li>
</ul>
<p>请用AIDL描述接口设计，并说明版本管理策略。</p>
<p><strong>Hint</strong>: 考虑异步回调和错误处理</p>
<details>
<summary>参考答案</summary>
<p>AIDL接口设计：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// ILed.aidl</span>
<span class="p">@</span><span class="n">VintfStability</span>
<span class="n">interface</span><span class="w"> </span><span class="n">ILed</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 设置LED颜色</span>
<span class="w">    </span><span class="n">Status</span><span class="w"> </span><span class="n">setColor</span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="n">LedColor</span><span class="w"> </span><span class="nb">color</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 设置闪烁模式</span>
<span class="w">    </span><span class="n">Status</span><span class="w"> </span><span class="n">setBlinkPattern</span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="n">BlinkPattern</span><span class="w"> </span><span class="n">pattern</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// 查询LED状态</span>
<span class="w">    </span><span class="n">LedState</span><span class="w"> </span><span class="n">getLedState</span><span class="p">();</span>

<span class="w">    </span><span class="c1">// 注册状态变化回调</span>
<span class="w">    </span><span class="n">Status</span><span class="w"> </span><span class="n">registerCallback</span><span class="p">(</span><span class="n">in</span><span class="w"> </span><span class="n">ILedCallback</span><span class="w"> </span><span class="n">callback</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 数据类型定义</span>
<span class="p">@</span><span class="n">VintfStability</span>
<span class="n">parcelable</span><span class="w"> </span><span class="n">LedColor</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">int</span><span class="w"> </span><span class="n">red</span><span class="p">;</span><span class="w">     </span><span class="c1">// 0-255</span>
<span class="w">    </span><span class="nb">int</span><span class="w"> </span><span class="n">green</span><span class="p">;</span><span class="w">   </span><span class="c1">// 0-255  </span>
<span class="w">    </span><span class="nb">int</span><span class="w"> </span><span class="n">blue</span><span class="p">;</span><span class="w">    </span><span class="c1">// 0-255</span>
<span class="p">}</span>

<span class="p">@</span><span class="n">VintfStability</span>
<span class="n">parcelable</span><span class="w"> </span><span class="n">BlinkPattern</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">int</span><span class="w"> </span><span class="n">onDurationMs</span><span class="p">;</span>
<span class="w">    </span><span class="nb">int</span><span class="w"> </span><span class="n">offDurationMs</span><span class="p">;</span>
<span class="w">    </span><span class="nb">int</span><span class="w"> </span><span class="n">repeatCount</span><span class="p">;</span><span class="w">  </span><span class="c1">// -1 for infinite</span>
<span class="p">}</span>
</code></pre></div>

<p>版本管理策略：</p>
<ul>
<li>使用@VintfStability确保接口稳定性</li>
<li>新增功能通过扩展接口实现</li>
<li>保持向后兼容，不修改已有方法签名</li>
</ul>
</details>
<h3 id="4">4. 签名安全分析题</h3>
<p>某厂商在发布ROM时使用了AOSP的testkey进行签名。请分析这种做法的安全风险，并提出改进方案。</p>
<p><strong>Hint</strong>: 考虑testkey的公开性和签名的作用</p>
<details>
<summary>参考答案</summary>
<p>安全风险分析：</p>
<ol>
<li>
<p><strong>testkey公开性</strong>：
   - testkey的私钥是公开的
   - 任何人都可以使用相同密钥签名
   - 无法验证ROM的真实来源</p>
</li>
<li>
<p><strong>潜在攻击</strong>：
   - 恶意应用可以获得系统权限
   - ROM可被任意修改和重新签名
   - 用户无法分辨官方和篡改版本</p>
</li>
</ol>
<p>改进方案：</p>
<ol>
<li>生成专用的发布密钥</li>
<li>使用HSM保护私钥</li>
<li>实施密钥分级管理</li>
<li>建立PKI体系和证书链</li>
<li>定期进行密钥轮换</li>
</ol>
</details>
<h3 id="5-ota">5. OTA更新设计题（挑战题）</h3>
<p>设计一个支持断点续传的OTA更新方案，要求：</p>
<ul>
<li>支持大文件（&gt;2GB）更新包</li>
<li>网络中断后可恢复</li>
<li>验证更新包完整性</li>
<li>最小化存储空间占用</li>
</ul>
<p><strong>Hint</strong>: 考虑分块下载和校验机制</p>
<details>
<summary>参考答案</summary>
<p>断点续传OTA方案设计：</p>
<ol>
<li>
<p><strong>分块策略</strong>：
   - 将更新包分割为固定大小块（如4MB）
   - 每块独立计算hash值
   - 元数据记录块信息和偏移量</p>
</li>
<li>
<p><strong>下载管理</strong>：
   - 记录已下载块的bitmap
   - 支持多线程并行下载
   - 失败块的重试机制</p>
</li>
<li>
<p><strong>完整性验证</strong>：
   - 块级别hash验证
   - 下载完成后整包验证
   - 使用Merkle树优化验证</p>
</li>
<li>
<p><strong>存储优化</strong>：
   - 流式解压，边下载边应用
   - 使用COW机制减少临时空间
   - 失败时只重传失败的块</p>
</li>
<li>
<p><strong>恢复机制</strong>：
   - 持久化下载状态
   - 断电保护设计
   - 自动恢复策略</p>
</li>
</ol>
</details>
<h3 id="6">6. 编译优化实践题（挑战题）</h3>
<p>某大型Android项目完整编译需要4小时，请提出至少5种优化方案，并分析每种方案的适用场景和潜在问题。</p>
<p><strong>Hint</strong>: 从硬件、软件、流程等多角度思考</p>
<details>
<summary>参考答案</summary>
<p>编译优化方案：</p>
<ol>
<li>
<p><strong>分布式编译（Goma/distcc）</strong>：
   - 适用：团队有编译服务器集群
   - 问题：网络延迟，环境一致性</p>
</li>
<li>
<p><strong>增量编译优化</strong>：
   - 适用：日常开发迭代
   - 问题：依赖关系复杂时可能出错</p>
</li>
<li>
<p><strong>ccache缓存</strong>：
   - 适用：频繁切换分支
   - 问题：缓存失效策略，磁盘空间</p>
</li>
<li>
<p><strong>模块化编译</strong>：
   - 适用：只关注特定模块
   - 问题：模块间依赖处理</p>
</li>
<li>
<p><strong>预编译头文件</strong>：
   - 适用：大量使用模板的C++代码
   - 问题：头文件修改影响大</p>
</li>
<li>
<p><strong>构建缓存服务</strong>：
   - 适用：CI/CD环境
   - 问题：缓存一致性，存储成本</p>
</li>
<li>
<p><strong>并行度调优</strong>：
   - 适用：高配置开发机
   - 问题：内存占用，系统负载</p>
</li>
</ol>
</details>
<h3 id="7-hal">7. HAL兼容性挑战题（挑战题）</h3>
<p>在Android系统升级时，如何设计HAL接口使得：</p>
<ul>
<li>旧版本HAL可以在新系统上工作</li>
<li>新版本HAL可以支持旧系统</li>
<li>同时保持性能和功能的最优化</li>
</ul>
<p>请给出具体的设计模式和实现策略。</p>
<p><strong>Hint</strong>: 考虑版本协商和功能降级</p>
<details>
<summary>参考答案</summary>
<p>HAL兼容性设计策略：</p>
<ol>
<li><strong>版本协商机制</strong>：</li>
</ol>
<div class="codehilite"><pre><span></span><code><span class="c1">// HAL端声明支持的版本范围</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">HalVersionInfo</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">minVersion</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">maxVersion</span><span class="p">;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">currentVersion</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div>

<ol start="2">
<li>
<p><strong>接口设计模式</strong>：
   - 使用Optional参数扩展
   - Feature flags标识能力
   - 默认值保证基础功能</p>
</li>
<li>
<p><strong>适配层设计</strong>：</p>
</li>
</ol>
<div class="codehilite"><pre><span></span><code>Client → Adapter → HAL
        ↓
    Version Check
        ↓
    Feature Set
</code></pre></div>

<ol start="4">
<li>
<p><strong>功能降级策略</strong>：
   - 运行时能力查询
   - 优雅降级路径
   - 性能vs功能权衡</p>
</li>
<li>
<p><strong>实现示例</strong>：
   - V1.0: 基础功能
   - V1.1: 添加可选参数
   - V2.0: 架构重构，保留V1适配</p>
</li>
<li>
<p><strong>测试矩阵</strong>：
   - 新系统+旧HAL
   - 旧系统+新HAL
   - 功能完整性验证</p>
</li>
</ol>
</details>
<h3 id="8">8. 安全编译挑战题（挑战题）</h3>
<p>设计一个安全的Android编译和签名流程，要求：</p>
<ul>
<li>源码到发布的完整可追溯性</li>
<li>防止供应链攻击</li>
<li>支持多方审计</li>
<li>紧急安全更新能力</li>
</ul>
<p><strong>Hint</strong>: 考虑可重现构建和透明度日志</p>
<details>
<summary>参考答案</summary>
<p>安全编译流程设计：</p>
<ol>
<li>
<p><strong>可重现构建</strong>：
   - 固定所有依赖版本
   - 消除时间戳等非确定因素
   - 使用容器化编译环境
   - 多方独立编译验证</p>
</li>
<li>
<p><strong>源码完整性</strong>：
   - Git提交签名
   - 代码审查强制
   - 依赖项hash固定
   - SBOM生成和验证</p>
</li>
<li>
<p><strong>编译环境安全</strong>：
   - 隔离的编译服务器
   - 只读源码访问
   - 编译日志存档
   - 环境完整性监控</p>
</li>
<li>
<p><strong>签名流程</strong>：
   - HSM中的签名操作
   - 多人授权机制
   - 签名日志记录
   - 证书透明度</p>
</li>
<li>
<p><strong>审计机制</strong>：
   - 构建日志区块链
   - 第三方验证节点
   - 公开的验证工具
   - 定期安全审计</p>
</li>
<li>
<p><strong>应急响应</strong>：
   - 快速通道流程
   - 但仍保持审计
   - 事后补充文档
   - 根因分析改进</p>
</li>
</ol>
</details>
<h2 id="gotchas">常见陷阱与错误 (Gotchas)</h2>
<h3 id="_12">编译环境陷阱</h3>
<ol>
<li>
<p><strong>Python版本冲突</strong>：
   - 错误：随意切换Python 2/3
   - 正确：使用virtualenv隔离环境</p>
</li>
<li>
<p><strong>并行编译内存不足</strong>：
   - 错误：<code>make -j32</code>在16GB机器上
   - 正确：根据RAM大小调整并行度</p>
</li>
<li>
<p><strong>ccache污染</strong>：
   - 错误：不同项目共用ccache
   - 正确：为每个项目设置独立缓存</p>
</li>
</ol>
<h3 id="_13">设备配置陷阱</h3>
<ol>
<li>
<p><strong>继承顺序错误</strong>：
   - 错误：先定义变量再继承
   - 正确：继承后再覆盖变量</p>
</li>
<li>
<p><strong>分区大小计算</strong>：
   - 错误：忽略文件系统开销
   - 正确：预留5-10%空间</p>
</li>
<li>
<p><strong>SELinux上下文</strong>：
   - 错误：直接禁用SELinux
   - 正确：正确配置策略文件</p>
</li>
</ol>
<h3 id="hal_3">HAL开发陷阱</h3>
<ol>
<li>
<p><strong>内存泄漏</strong>：
   - 错误：忘记释放HAL分配的内存
   - 正确：使用RAII或智能指针</p>
</li>
<li>
<p><strong>死锁问题</strong>：
   - 错误：持锁调用回调
   - 正确：释放锁后再回调</p>
</li>
<li>
<p><strong>版本兼容</strong>：
   - 错误：修改已发布接口
   - 正确：新增接口方法</p>
</li>
</ol>
<h3 id="_14">签名发布陷阱</h3>
<ol>
<li>
<p><strong>使用测试密钥</strong>：
   - 错误：生产环境用testkey
   - 正确：生成专用发布密钥</p>
</li>
<li>
<p><strong>密钥泄露</strong>：
   - 错误：密钥提交到代码库
   - 正确：使用密钥管理服务</p>
</li>
<li>
<p><strong>OTA包错误</strong>：
   - 错误：跳版本升级
   - 正确：提供完整升级路径</p>
</li>
</ol>
<h2 id="_15">最佳实践检查清单</h2>
<h3 id="_16">编译环境</h3>
<ul>
<li>[ ] 使用官方推荐的OS版本</li>
<li>[ ] 配置足够的swap空间</li>
<li>[ ] 启用ccache并设置合理大小</li>
<li>[ ] 使用SSD存储源码</li>
<li>[ ] 定期清理out目录</li>
<li>[ ] 备份重要的编译产物</li>
</ul>
<h3 id="_17">设备配置</h3>
<ul>
<li>[ ] 遵循AOSP命名规范</li>
<li>[ ] 合理组织配置文件结构</li>
<li>[ ] 使用变量避免硬编码</li>
<li>[ ] 添加充分的注释</li>
<li>[ ] 测试不同产品变体</li>
<li>[ ] 验证OTA更新路径</li>
</ul>
<h3 id="hal_4">HAL开发</h3>
<ul>
<li>[ ] 遵循接口设计原则</li>
<li>[ ] 实现完整错误处理</li>
<li>[ ] 添加VTS测试用例</li>
<li>[ ] 性能benchmark测试</li>
<li>[ ] 文档化所有接口</li>
<li>[ ] 考虑功耗影响</li>
</ul>
<h3 id="_18">签名发布</h3>
<ul>
<li>[ ] 使用独立的签名密钥</li>
<li>[ ] 实施密钥轮换计划</li>
<li>[ ] 测试OTA更新流程</li>
<li>[ ] 验证防回滚保护</li>
<li>[ ] 建立应急响应流程</li>
<li>[ ] 保留构建artifacts</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter30.html" class="nav-link prev">← 附录A：调试工具与技巧</a><a href="chapter32.html" class="nav-link next">第32章：参考资源 →</a></nav>
        </main>
    </div>
</body>
</html>