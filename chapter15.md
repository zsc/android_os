# 第15章：漏洞案例分析

## 章节大纲

### 15.1 Stagefright漏洞剖析
- 15.1.1 Stagefright架构概述
- 15.1.2 整数溢出漏洞原理
- 15.1.3 远程代码执行链条
- 15.1.4 补丁分析与影响

### 15.2 权限提升漏洞
- 15.2.1 脏牛（DirtyCOW）在Android上的利用
- 15.2.2 内核权限提升漏洞分析
- 15.2.3 系统服务提权漏洞
- 15.2.4 SELinux绕过技术

### 15.3 Binder漏洞利用
- 15.3.1 Binder内存损坏漏洞
- 15.3.2 类型混淆攻击
- 15.3.3 UAF（Use-After-Free）利用
- 15.3.4 跨进程攻击向量

### 15.4 防护机制演进
- 15.4.1 ASLR与PIE增强
- 15.4.2 SELinux策略强化
- 15.4.3 整数溢出检测
- 15.4.4 CFI（控制流完整性）实施

本章将深入分析Android历史上的重大安全漏洞，理解其技术原理、利用方法以及Google的修复策略。通过这些真实案例，读者将掌握Android安全威胁的本质，以及如何构建更安全的系统。

## 15.1 Stagefright漏洞剖析

### 15.1.1 Stagefright架构概述

Stagefright是Android的媒体播放引擎，负责处理音视频的解码和播放。它支持多种媒体格式，包括MP4、3GPP、MPEG-TS等。架构上，Stagefright位于MediaServer进程中，具有media权限，可以访问音频、视频和相机等敏感资源。

关键组件包括：
- **OMXCodec**：与硬件编解码器的接口层
- **MediaExtractor**：负责解析容器格式，提取音视频流
- **DataSource**：数据源抽象，支持本地文件和网络流
- **MetaData**：媒体元数据处理

与iOS的AVFoundation相比，Stagefright的设计更加模块化，但也引入了更多的攻击面。iOS将媒体处理放在独立的进程中，并使用更严格的沙箱策略。

### 15.1.2 整数溢出漏洞原理

2015年发现的Stagefright漏洞（CVE-2015-1538系列）主要源于整数溢出。在处理MP4文件的atom（数据块）时，代码没有正确验证size字段：

关键漏洞点在MPEG4Extractor::parseChunk函数中，当解析'tx3g'（文本样式）atom时：
- 读取chunk_size（32位无符号整数）
- 分配chunk_size大小的缓冲区
- 但在某些计算中，chunk_size + offset可能溢出

攻击者可以构造恶意MP4文件：
1. 设置极大的chunk_size值（接近0xFFFFFFFF）
2. 触发整数溢出，导致实际分配的缓冲区很小
3. 后续的memcpy操作会造成堆溢出

与iOS相比，Android的媒体解析代码更多使用C/C++直接操作内存，而iOS在Swift层面有更多的安全检查。

### 15.1.3 远程代码执行链条

Stagefright漏洞的可怕之处在于可以通过多种途径触发：

**攻击向量**：
1. **彩信（MMS）**：最危险的攻击方式，无需用户交互
   - 攻击者发送包含恶意媒体文件的彩信
   - Hangouts等应用会自动下载并预处理媒体
   - 在用户查看消息前就可能被攻击

2. **浏览器**：通过恶意网页触发
   - HTML5 video标签自动加载
   - MediaPlayer预览功能

3. **即时通讯**：WhatsApp、微信等应用的媒体预览

**利用链条**：
1. **堆喷射（Heap Spray）**：在堆上布置大量可控数据
2. **信息泄露**：利用其他漏洞获取ASLR基址
3. **ROP链构造**：绕过DEP保护
4. **权限提升**：从media用户提权到system

关键利用技术：
- 使用MP4的多个atom进行多次溢出
- 利用dlmalloc的特性控制堆布局
- 通过覆盖函数指针获得控制流

### 15.1.4 补丁分析与影响

Google的修复策略分为多个层次：

**紧急补丁**（2015年7月）：
- 添加整数溢出检查：使用__builtin_add_overflow等编译器内建函数
- 限制atom大小：设置合理的上限（如64MB）
- 增强边界检查：在所有内存操作前验证

**长期改进**：
1. **架构重构**：
   - 将媒体解析移到独立进程
   - 降低MediaServer权限
   - 实施更严格的SELinux策略

2. **代码加固**：
   - 启用整数清理器（Integer Sanitizer）
   - 使用更安全的内存分配API
   - 静态分析工具集成

3. **月度安全更新**：建立定期补丁发布机制

**与其他系统对比**：
- iOS：媒体处理本就在独立进程，权限更低
- 鸿蒙：采用形式化验证的媒体解析器
- Linux桌面：GStreamer等框架有类似问题，但攻击面较小

影响评估：
- 影响Android 2.2到5.1.1的9.5亿设备
- 促进了Android安全更新机制的建立
- 推动了Project Treble，便于快速部署补丁

## 15.2 权限提升漏洞

### 15.2.1 脏牛（DirtyCOW）在Android上的利用

DirtyCOW（CVE-2016-5195）是Linux内核的竞态条件漏洞，影响了Android 4.4到7.0的设备。该漏洞存在于内核的内存子系统中，允许非特权用户获得只读内存映射的写权限。

**漏洞原理**：
- 内核的写时复制（Copy-on-Write, COW）机制存在竞态条件
- get_user_pages()函数在处理私有只读映射时的缺陷
- 通过madvise(MADV_DONTNEED)可以触发页面回收
- 多线程竞争可以在COW破坏前获得写权限

**Android利用特点**：
1. **目标选择**：
   - /system/bin/app_process：Zygote启动程序
   - /system/lib/libc.so：C库函数
   - vDSO（虚拟动态共享对象）

2. **利用步骤**：
   - 打开目标文件的只读映射
   - 创建私有映射（MAP_PRIVATE）
   - 一个线程不断write()，另一个线程madvise()
   - 竞态成功后可修改只读文件

3. **提权路径**：
   - 修改app_process注入代码
   - 替换系统库函数
   - 获得root权限执行任意代码

### 15.2.2 内核权限提升漏洞分析

Android内核提权漏洞通常利用以下几类问题：

**1. 内存损坏类**：
- **CVE-2016-3809**：Qualcomm驱动的缓冲区溢出
  - 影响：MSM内核驱动
  - 利用：通过ioctl触发溢出，覆盖内核结构
  - 修复：添加边界检查

- **CVE-2016-2059**：Linux内核IPC漏洞
  - 影响：keyring子系统
  - 利用：UAF导致任意内核内存读写
  - 修复：正确的引用计数

**2. 逻辑漏洞类**：
- **CVE-2015-3636**（PingPong Root）：
  - 影响：ping socket实现
  - 利用：构造特殊的socket操作序列
  - 获得内核任意地址读写能力

**3. 驱动漏洞**：
- GPU驱动：Mali、Adreno驱动的各种漏洞
- 相机驱动：特权ioctl接口
- 音频驱动：DSP通信接口

**与其他系统对比**：
- iOS：内核攻击面更小，驱动代码审计更严格
- Linux桌面：模块化程度高，但Android的驱动更多
- 鸿蒙：微内核设计，驱动运行在用户态

### 15.2.3 系统服务提权漏洞

除了内核漏洞，Android的系统服务也是提权的重要目标。这些服务运行在system权限下，一旦被攻破就能获得高权限。

**典型案例分析**：

**1. ActivityManager提权（CVE-2017-0806）**：
- 漏洞位置：ActivityManagerService的任务切换逻辑
- 原理：Race condition导致权限检查绕过
- 影响：可以启动任意Activity，包括系统设置
- 利用方式：
  - 构造特殊的Intent序列
  - 在权限检查的时间窗口内切换任务
  - 最终以system权限执行代码

**2. PackageManager漏洞**：
- **Janus漏洞（CVE-2017-13156）**：
  - APK签名验证绕过
  - 利用DEX和APK的文件格式差异
  - 可以在已签名APK中注入代码
  
- **权限升级漏洞**：
  - 利用权限继承机制
  - 通过共享UID获得额外权限

**3. MediaProjection服务漏洞**：
- 屏幕录制权限绕过
- 可以在用户不知情下截屏
- 涉及隐私泄露风险

### 15.2.4 SELinux绕过技术

SELinux是Android的强制访问控制系统，但仍存在绕过方法：

**1. 策略漏洞**：
- **域转换漏洞**：利用不当的domain transition
- **标签错误**：文件或进程的错误标签
- **过宽的规则**：某些neverallow规则的例外

**2. 内核漏洞组合**：
- 先获得内核权限
- 直接修改SELinux状态
- 或者注入到init进程

**3. Zygote注入**：
- 在SELinux完全初始化前注入
- 利用app_process的特殊地位
- 继承Zygote的SELinux上下文

**4. 供应商定制漏洞**：
- OEM添加的SELinux规则often过于宽松
- 自定义系统服务的策略错误
- 硬件抽象层（HAL）的权限问题

**防御演进**：
- Android 8.0：Project Treble隔离vendor策略
- Android 9.0：更严格的neverallow规则
- Android 10：动态策略更新机制

与iOS对比：
- iOS使用沙箱+entitlement系统
- Android的SELinux更灵活但也更复杂
- 鸿蒙采用能力系统，细粒度更高

## 15.3 Binder漏洞利用

### 15.3.1 Binder内存损坏漏洞

Binder作为Android的核心IPC机制，其漏洞影响巨大。Binder驱动在内核态处理大量用户数据，容易出现内存损坏问题。

**典型漏洞案例：CVE-2019-2215**

这是一个Binder驱动的UAF漏洞，影响Android 8.0-10的设备：

**漏洞成因**：
- binder_thread_release()函数中的逻辑错误
- 线程退出时，错误地释放了仍在使用的vector
- 导致悬空指针，可被重新分配利用

**利用技术**：
1. **触发UAF**：
   - 创建binder线程
   - 触发特定的错误路径
   - 导致premature free

2. **堆布局控制**：
   - 使用pipe buffers占位
   - 精确控制内存分配
   - 重用被释放的内存

3. **任意读写**：
   - 覆盖关键数据结构
   - 获得内核任意地址读写
   - 最终提权到root

### 15.3.2 类型混淆攻击

Binder的类型系统依赖于正确的Parcel序列化，类型混淆可导致严重后果。

**Bundle机制漏洞**：
- Android使用Bundle传递复杂数据
- Bundle内部使用Parcel序列化
- 恶意构造的Bundle可触发类型混淆

**LaunchAnyWhere漏洞（CVE-2017-13286）**：
1. **原理**：
   - AccountManager的addAccount流程
   - Bundle被错误地反序列化两次
   - 第二次可以注入任意Intent

2. **利用效果**：
   - 绕过权限检查启动任意Activity
   - 包括系统设置等敏感界面
   - 可用于钓鱼或提权

**序列化漏洞模式**：
- 长度字段溢出
- 嵌套对象循环引用
- 自定义Parcelable的实现错误

### 15.3.3 UAF（Use-After-Free）利用

UAF是Binder最常见的漏洞类型，主要出现在引用计数管理错误时。

**典型场景**：
1. **强弱引用混淆**：
   - sp<>（强指针）和wp<>（弱指针）使用错误
   - 导致对象过早释放
   - 后续访问造成UAF

2. **死亡通知竞态**：
   - LinkToDeath机制的竞态条件
   - 进程死亡时的清理不当
   - 回调函数访问已释放对象

**利用技术演进**：
- 早期：简单的函数指针覆盖
- 中期：配合KASLR信息泄露
- 现在：需要绕过CFI等防护

### 15.3.4 跨进程攻击向量

Binder的跨进程特性带来独特的攻击面：

**1. 事务洪水攻击**：
- 发送大量Binder事务
- 耗尽目标进程的Binder缓冲区
- 导致合法请求被拒绝

**2. 死锁攻击**：
- 构造循环的同步Binder调用
- 导致系统服务死锁
- 影响整个系统稳定性

**3. 侧信道攻击**：
- 通过Binder调用时延推断信息
- 利用共享内存页面的缓存行为
- 可能泄露敏感数据

**4. 权限混淆攻击**：
- 利用Binder的UID传递机制
- 在多跳调用中混淆调用者身份
- 绕过权限检查

**防护机制对比**：
- iOS XPC：使用更严格的类型系统
- D-Bus（Linux）：性能较差但更安全
- 鸿蒙分布式软总线：增加了设备认证层